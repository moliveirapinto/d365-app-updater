name: Scheduled App Updates

on:
  schedule:
    # Run every hour at minute 5
    - cron: '5 * * * *'
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    
    steps:
      - name: Get enabled schedules from Supabase
        id: get-schedules
        env:
          # Use service_role key to read secrets (bypasses RLS)
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Fetch schedules with their secrets using service_role key
          SCHEDULES=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/update_schedules?enabled=eq.true&select=*" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Fetch secrets from secure table
          SECRETS=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/schedule_secrets?select=schedule_id,client_secret" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Handle empty secrets array
          if [ -z "$SECRETS" ] || [ "$SECRETS" = "[]" ]; then
            SECRETS="[]"
          fi
          
          # Merge schedules with their secrets (compact to single line with -c)
          MERGED=$(echo "$SCHEDULES" | jq -c --argjson secrets "$SECRETS" '
            . as $schedules | 
            (if $secrets == [] then {} else ($secrets | map({(.schedule_id | tostring): .client_secret}) | add) end) as $secretMap |
            $schedules | map(. + (if $secretMap[.id | tostring] then {client_secret: $secretMap[.id | tostring]} else {} end))
          ')
          
          # Use delimiter for multiline-safe output
          echo "schedules<<EOF" >> $GITHUB_OUTPUT
          echo "$MERGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Found $(echo "$MERGED" | jq length) schedules"
          
      - name: Process schedules
        env:
          SCHEDULES: ${{ steps.get-schedules.outputs.schedules }}
          SUPABASE_URL: https://fpekzltxukikaixebeeu.supabase.co
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          echo "========================================="
          echo "üïê CURRENT TIME INFO"
          echo "========================================="
          echo "UTC:     $(date -u '+%A %Y-%m-%d %H:%M:%S')"
          echo "UTC day: $(date -u +%w), UTC hour: $(date -u +%H):00"
          echo ""
          
          # Check if schedules is empty or null
          if [ -z "$SCHEDULES" ] || [ "$SCHEDULES" = "[]" ] || [ "$SCHEDULES" = "null" ]; then
            echo "‚ùå No enabled schedules found. Check SUPABASE_SERVICE_KEY secret."
            echo "Raw SCHEDULES value: '$SCHEDULES'"
            exit 0
          fi
          
          SCHEDULE_COUNT=$(echo "$SCHEDULES" | jq 'length' 2>/dev/null || echo "0")
          echo "üìã Found $SCHEDULE_COUNT enabled schedule(s)"
          echo ""
          
          # Parse and process each schedule
          echo "$SCHEDULES" | jq -c '.[]' 2>/dev/null | while read schedule; do
            SCHEDULE_DAY=$(echo $schedule | jq -r '.day_of_week')
            SCHEDULE_TIME=$(echo $schedule | jq -r '.time_utc')
            SCHEDULE_TZ=$(echo $schedule | jq -r '.timezone // "UTC"')
            ORG_URL=$(echo $schedule | jq -r '.org_url')
            ENV_ID=$(echo $schedule | jq -r '.environment_id')
            USER_EMAIL=$(echo $schedule | jq -r '.user_email')
            SCHEDULE_ID=$(echo $schedule | jq -r '.id')
            
            # Get per-user credentials from schedule
            USER_CLIENT_ID=$(echo $schedule | jq -r '.client_id // empty')
            USER_CLIENT_SECRET=$(echo $schedule | jq -r '.client_secret // empty')
            USER_TENANT_ID=$(echo $schedule | jq -r '.tenant_id // empty')
            
            # Get current time in the schedule's timezone
            CURRENT_LOCAL_DAY=$(TZ="$SCHEDULE_TZ" date +%w)
            CURRENT_LOCAL_HOUR=$(TZ="$SCHEDULE_TZ" date +%H):00
            CURRENT_LOCAL_TIME=$(TZ="$SCHEDULE_TZ" date '+%A %Y-%m-%d %H:%M:%S %Z')
            
            echo "========================================="
            echo "üìÖ SCHEDULE #$SCHEDULE_ID ($USER_EMAIL)"
            echo "========================================="
            echo "  Org URL:       $ORG_URL"
            echo "  Env ID:        $ENV_ID"
            echo "  Schedule:      Day $SCHEDULE_DAY at $SCHEDULE_TIME ($SCHEDULE_TZ)"
            echo "  Current local: Day $CURRENT_LOCAL_DAY at $CURRENT_LOCAL_HOUR ($CURRENT_LOCAL_TIME)"
            echo "  Client ID:     ${USER_CLIENT_ID:0:8}..."
            echo "  Tenant ID:     ${USER_TENANT_ID:0:8}..."
            echo "  Has secret:    $([ -n '$USER_CLIENT_SECRET' ] && echo 'Yes' || echo 'No')"
            echo ""
            
            # Validate credentials
            if [ -z "$USER_CLIENT_ID" ] || [ -z "$USER_CLIENT_SECRET" ]; then
              echo "  ‚ö†Ô∏è SKIPPED: Missing credentials (client_id or client_secret empty)"
              echo ""
              continue
            fi
            
            if [ -z "$USER_TENANT_ID" ]; then
              echo "  ‚ö†Ô∏è SKIPPED: Missing tenant_id"
              echo ""
              continue
            fi
            
            # Check if schedule matches current LOCAL time (in user's timezone)
            if [ "$SCHEDULE_DAY" != "$CURRENT_LOCAL_DAY" ] || [ "$SCHEDULE_TIME" != "$CURRENT_LOCAL_HOUR" ]; then
              echo "  ‚è≠Ô∏è SKIPPED: Time doesn't match"
              echo "     Expected: Day=$SCHEDULE_DAY Time=$SCHEDULE_TIME"
              echo "     Current:  Day=$CURRENT_LOCAL_DAY Time=$CURRENT_LOCAL_HOUR"
              echo ""
              
              # Still update Supabase to show the workflow DID run (just not matching time)
              curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                -H "apikey: $SUPABASE_SERVICE_KEY" \
                -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                -H "Content-Type: application/json" \
                -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"skipped\"}" > /dev/null 2>&1
              continue
            fi
            
            echo "  ‚úÖ TIME MATCH! Processing updates..."
            echo ""
            
            # ‚îÄ‚îÄ Step 1: Get access token for Power Platform API ‚îÄ‚îÄ
            echo "  üîë Step 1: Acquiring token for Power Platform API..."
            TOKEN_RESPONSE=$(curl -s -X POST "https://login.microsoftonline.com/${USER_TENANT_ID}/oauth2/v2.0/token" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "client_id=${USER_CLIENT_ID}&client_secret=${USER_CLIENT_SECRET}&grant_type=client_credentials&scope=https://api.powerplatform.com/.default")
            
            ACCESS_TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.access_token // empty')
            TOKEN_ERROR=$(echo $TOKEN_RESPONSE | jq -r '.error_description // .error // empty')
            
            if [ -z "$ACCESS_TOKEN" ]; then
              echo "  ‚ùå FAILED to get Power Platform API token"
              echo "  Error: $TOKEN_ERROR"
              echo ""
              
              # Try Dataverse token as fallback for diagnostics
              echo "  üîë Trying Dataverse token (${ORG_URL}/.default)..."
              DV_TOKEN_RESPONSE=$(curl -s -X POST "https://login.microsoftonline.com/${USER_TENANT_ID}/oauth2/v2.0/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "client_id=${USER_CLIENT_ID}&client_secret=${USER_CLIENT_SECRET}&grant_type=client_credentials&scope=${ORG_URL}/.default")
              DV_TOKEN=$(echo $DV_TOKEN_RESPONSE | jq -r '.access_token // empty')
              DV_ERROR=$(echo $DV_TOKEN_RESPONSE | jq -r '.error_description // .error // empty')
              
              if [ -n "$DV_TOKEN" ]; then
                echo "  ‚úÖ Dataverse token works! Using Dataverse API for updates..."
                ACCESS_TOKEN="$DV_TOKEN"
                USE_DATAVERSE=true
              else
                echo "  ‚ùå Dataverse token also failed: $DV_ERROR"
                
                curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                  -H "apikey: $SUPABASE_SERVICE_KEY" \
                  -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"failed\"}" > /dev/null 2>&1
                continue
              fi
            else
              echo "  ‚úÖ Got Power Platform API token"
              USE_DATAVERSE=false
            fi
            echo ""
            
            # ‚îÄ‚îÄ Step 2: Fetch installed apps ‚îÄ‚îÄ
            echo "  üì¶ Step 2: Fetching installed apps..."
            INSTALLED_RESPONSE=$(curl -s -w "\n%{http_code}" "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages?appInstallState=Installed&api-version=2022-03-01-preview" \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Accept: application/json")
            
            INST_HTTP=$(echo "$INSTALLED_RESPONSE" | tail -1)
            INSTALLED_APPS=$(echo "$INSTALLED_RESPONSE" | head -n -1)
            INSTALLED_COUNT=$(echo "$INSTALLED_APPS" | jq '.value | length' 2>/dev/null || echo "0")
            
            echo "  HTTP status: $INST_HTTP"
            echo "  Installed apps found: $INSTALLED_COUNT"
            
            if [ "$INST_HTTP" != "200" ]; then
              echo "  ‚ùå Failed to fetch installed apps"
              ERROR_MSG=$(echo "$INSTALLED_APPS" | jq -r '.error.message // .message // empty' 2>/dev/null)
              echo "  Error: $ERROR_MSG"
              echo "  Full response: $(echo $INSTALLED_APPS | head -c 500)"
              
              curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                -H "apikey: $SUPABASE_SERVICE_KEY" \
                -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                -H "Content-Type: application/json" \
                -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"failed\"}" > /dev/null 2>&1
              continue
            fi
            echo ""
            
            # ‚îÄ‚îÄ Step 3: Fetch catalog apps ‚îÄ‚îÄ
            echo "  üì¶ Step 3: Fetching catalog apps..."
            CATALOG_RESPONSE=$(curl -s -w "\n%{http_code}" "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages?api-version=2022-03-01-preview" \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -H "Accept: application/json")
            
            CAT_HTTP=$(echo "$CATALOG_RESPONSE" | tail -1)
            CATALOG_APPS=$(echo "$CATALOG_RESPONSE" | head -n -1)
            CATALOG_COUNT=$(echo "$CATALOG_APPS" | jq '.value | length' 2>/dev/null || echo "0")
            
            echo "  HTTP status: $CAT_HTTP"
            echo "  Catalog apps found: $CATALOG_COUNT"
            echo ""
            
            # ‚îÄ‚îÄ Step 4: Compare versions and update ‚îÄ‚îÄ
            echo "  üîç Step 4: Comparing versions..."
            
            # Build results using temp file (avoid subshell variable loss)
            RESULTS_FILE=$(mktemp)
            echo "0 0" > "$RESULTS_FILE"
            
            echo "$INSTALLED_APPS" | jq -c '.value[]?' 2>/dev/null | while read installed; do
              APP_ID=$(echo $installed | jq -r '.applicationId // empty')
              APP_NAME=$(echo $installed | jq -r '.localizedName // .applicationName // "Unknown"')
              INSTALLED_VERSION=$(echo $installed | jq -r '.version // "0.0.0"')
              UNIQUE_NAME=$(echo $installed | jq -r '.uniqueName // empty')
              
              if [ -z "$APP_ID" ]; then continue; fi
              
              # Find latest version in catalog
              CATALOG_VERSION=$(echo "$CATALOG_APPS" | jq -r --arg id "$APP_ID" '[.value[]? | select(.applicationId == $id)] | sort_by(.version) | last | .version // "0.0.0"')
              CATALOG_UNIQUE=$(echo "$CATALOG_APPS" | jq -r --arg id "$APP_ID" '[.value[]? | select(.applicationId == $id)] | sort_by(.version) | last | .uniqueName // empty')
              
              if [ "$CATALOG_VERSION" = "0.0.0" ] || [ "$CATALOG_VERSION" = "$INSTALLED_VERSION" ]; then
                continue
              fi
              
              # Compare versions  
              HIGHER=$(echo -e "$INSTALLED_VERSION\n$CATALOG_VERSION" | sort -V | tail -1)
              if [ "$HIGHER" = "$CATALOG_VERSION" ] && [ "$HIGHER" != "$INSTALLED_VERSION" ]; then
                echo "  üîÑ UPDATE: $APP_NAME"
                echo "     Current:  $INSTALLED_VERSION"
                echo "     Catalog:  $CATALOG_VERSION"
                
                UPDATE_NAME="${CATALOG_UNIQUE:-$UNIQUE_NAME}"
                echo "     Package:  $UPDATE_NAME"
                
                UPDATE_RESULT=$(curl -s -w "\n%{http_code}" -X POST "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages/${UPDATE_NAME}/install?api-version=2022-03-01-preview" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Content-Type: application/json")
                
                UP_HTTP=$(echo "$UPDATE_RESULT" | tail -1)
                UP_BODY=$(echo "$UPDATE_RESULT" | head -n -1)
                
                if [ "$UP_HTTP" -ge 200 ] 2>/dev/null && [ "$UP_HTTP" -lt 300 ] 2>/dev/null; then
                  echo "     ‚úÖ Update submitted (HTTP $UP_HTTP)"
                  read u f < "$RESULTS_FILE"; echo "$((u+1)) $f" > "$RESULTS_FILE"
                else
                  echo "     ‚ùå Update failed (HTTP $UP_HTTP): $(echo $UP_BODY | head -c 200)"
                  read u f < "$RESULTS_FILE"; echo "$u $((f+1))" > "$RESULTS_FILE"
                fi
              fi
            done
            
            read UPDATED_COUNT FAILED_COUNT < "$RESULTS_FILE"
            rm -f "$RESULTS_FILE"
            
            echo ""
            echo "  üìä RESULTS: $UPDATED_COUNT updated, $FAILED_COUNT failed"
            echo ""
            
            # Update Supabase with results
            curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
              -H "apikey: $SUPABASE_SERVICE_KEY" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/json" \
              -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"success\"}" > /dev/null 2>&1
            
            echo "  ‚úÖ Schedule $SCHEDULE_ID status updated in Supabase"
          done
          
          echo "üéâ Done processing schedules"
