name: Scheduled App Updates

on:
  schedule:
    # Run every hour at minute 5
    - cron: '5 * * * *'
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    
    steps:
      - name: Get enabled schedules from Supabase
        id: get-schedules
        env:
          # Use service_role key to read secrets (bypasses RLS)
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Fetch schedules with their secrets using service_role key
          SCHEDULES=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/update_schedules?enabled=eq.true&select=*" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Fetch secrets from secure table
          SECRETS=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/schedule_secrets?select=schedule_id,client_secret" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Handle empty secrets array
          if [ -z "$SECRETS" ] || [ "$SECRETS" = "[]" ]; then
            SECRETS="[]"
          fi
          
          # Merge schedules with their secrets (compact to single line with -c)
          MERGED=$(echo "$SCHEDULES" | jq -c --argjson secrets "$SECRETS" '
            . as $schedules | 
            (if $secrets == [] then {} else ($secrets | map({(.schedule_id | tostring): .client_secret}) | add) end) as $secretMap |
            $schedules | map(. + (if $secretMap[.id | tostring] then {client_secret: $secretMap[.id | tostring]} else {} end))
          ')
          
          # Use delimiter for multiline-safe output
          echo "schedules<<EOF" >> $GITHUB_OUTPUT
          echo "$MERGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Found $(echo "$MERGED" | jq length) schedules"
          
      - name: Process schedules
        env:
          SCHEDULES: ${{ steps.get-schedules.outputs.schedules }}
          SUPABASE_URL: https://fpekzltxukikaixebeeu.supabase.co
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Get current UTC time
          CURRENT_UTC_DAY=$(date -u +%w)
          CURRENT_UTC_HOUR=$(date -u +%H):00
          
          echo "Current UTC: Day $CURRENT_UTC_DAY, Time $CURRENT_UTC_HOUR"
          
          # Check if schedules is empty or null
          if [ -z "$SCHEDULES" ] || [ "$SCHEDULES" = "[]" ]; then
            echo "No enabled schedules found"
            exit 0
          fi
          
          # Parse and process each schedule
          echo "$SCHEDULES" | jq -c '.[]' 2>/dev/null | while read schedule; do
            SCHEDULE_DAY=$(echo $schedule | jq -r '.day_of_week')
            SCHEDULE_TIME=$(echo $schedule | jq -r '.time_utc')
            SCHEDULE_TZ=$(echo $schedule | jq -r '.timezone // "UTC"')
            ORG_URL=$(echo $schedule | jq -r '.org_url')
            ENV_ID=$(echo $schedule | jq -r '.environment_id')
            USER_EMAIL=$(echo $schedule | jq -r '.user_email')
            SCHEDULE_ID=$(echo $schedule | jq -r '.id')
            
            # Get per-user credentials from schedule
            USER_CLIENT_ID=$(echo $schedule | jq -r '.client_id // empty')
            USER_CLIENT_SECRET=$(echo $schedule | jq -r '.client_secret // empty')
            USER_TENANT_ID=$(echo $schedule | jq -r '.tenant_id // empty')
            
            # Get current time in the schedule's timezone
            CURRENT_LOCAL_DAY=$(TZ="$SCHEDULE_TZ" date +%w)
            CURRENT_LOCAL_HOUR=$(TZ="$SCHEDULE_TZ" date +%H):00
            
            echo "Checking schedule $SCHEDULE_ID: Day $SCHEDULE_DAY at $SCHEDULE_TIME ($SCHEDULE_TZ)"
            echo "  Current local time in $SCHEDULE_TZ: Day $CURRENT_LOCAL_DAY, Time $CURRENT_LOCAL_HOUR"
            
            # Validate credentials
            if [ -z "$USER_CLIENT_ID" ] || [ -z "$USER_CLIENT_SECRET" ]; then
              echo "‚ö†Ô∏è Schedule $SCHEDULE_ID missing credentials, skipping"
              continue
            fi
            
            # Check if schedule matches current LOCAL time (in user's timezone)
            if [ "$SCHEDULE_DAY" = "$CURRENT_LOCAL_DAY" ] && [ "$SCHEDULE_TIME" = "$CURRENT_LOCAL_HOUR" ]; then
              echo "‚úÖ Schedule matches! Processing updates for $ORG_URL"
              
              # Get access token using per-user credentials
              TOKEN_RESPONSE=$(curl -s -X POST "https://login.microsoftonline.com/${USER_TENANT_ID}/oauth2/v2.0/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "client_id=${USER_CLIENT_ID}&client_secret=${USER_CLIENT_SECRET}&grant_type=client_credentials&scope=${ORG_URL}/.default")
              
              ACCESS_TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.access_token')
              
              if [ "$ACCESS_TOKEN" != "null" ] && [ -n "$ACCESS_TOKEN" ]; then
                echo "üîë Got access token, fetching apps with updates..."
                
                # Get apps with updates available
                APPS_RESPONSE=$(curl -s "${ORG_URL}/api/data/v9.2/msdyn_solutioncomponentcountssummaries?\$filter=msdyn_componenttype%20eq%20300" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "OData-MaxVersion: 4.0" \
                  -H "OData-Version: 4.0" \
                  -H "Accept: application/json")
                
                echo "üì¶ Apps response received"
                
                # Update last_run status in Supabase
                curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                  -H "apikey: $SUPABASE_SERVICE_KEY" \
                  -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"success\"}"
                
                echo "‚úÖ Updated schedule $SCHEDULE_ID status to success"
              else
                echo "‚ùå Failed to get access token for $ORG_URL"
                echo "Token response: $TOKEN_RESPONSE"
                
                # Update status as failed
                curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                  -H "apikey: $SUPABASE_SERVICE_KEY" \
                  -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"failed\"}"
              fi
            else
              echo "‚è≠Ô∏è Schedule $SCHEDULE_ID doesn't match current time, skipping"
            fi
          done
          
          echo "üéâ Done processing schedules"
