name: Scheduled App Updates

on:
  schedule:
    # Run every hour at minute 5
    - cron: '5 * * * *'
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  check-and-update:
    runs-on: ubuntu-latest
    
    steps:
      - name: Get enabled schedules from Supabase
        id: get-schedules
        env:
          # Use service_role key to read secrets (bypasses RLS)
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Fetch schedules with their secrets using service_role key
          SCHEDULES=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/update_schedules?enabled=eq.true&select=*" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Fetch secrets from secure table
          SECRETS=$(curl -s "https://fpekzltxukikaixebeeu.supabase.co/rest/v1/schedule_secrets?select=schedule_id,client_secret" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY")
          
          # Handle empty secrets array
          if [ -z "$SECRETS" ] || [ "$SECRETS" = "[]" ]; then
            SECRETS="[]"
          fi
          
          # Merge schedules with their secrets (compact to single line with -c)
          MERGED=$(echo "$SCHEDULES" | jq -c --argjson secrets "$SECRETS" '
            . as $schedules | 
            (if $secrets == [] then {} else ($secrets | map({(.schedule_id | tostring): .client_secret}) | add) end) as $secretMap |
            $schedules | map(. + (if $secretMap[.id | tostring] then {client_secret: $secretMap[.id | tostring]} else {} end))
          ')
          
          # Use delimiter for multiline-safe output
          echo "schedules<<EOF" >> $GITHUB_OUTPUT
          echo "$MERGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Found $(echo "$MERGED" | jq length) schedules"
          
      - name: Process schedules
        env:
          SCHEDULES: ${{ steps.get-schedules.outputs.schedules }}
          SUPABASE_URL: https://fpekzltxukikaixebeeu.supabase.co
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Get current UTC time
          CURRENT_UTC_DAY=$(date -u +%w)
          CURRENT_UTC_HOUR=$(date -u +%H):00
          
          echo "Current UTC: Day $CURRENT_UTC_DAY, Time $CURRENT_UTC_HOUR"
          
          # Check if schedules is empty or null
          if [ -z "$SCHEDULES" ] || [ "$SCHEDULES" = "[]" ]; then
            echo "No enabled schedules found"
            exit 0
          fi
          
          # Parse and process each schedule
          echo "$SCHEDULES" | jq -c '.[]' 2>/dev/null | while read schedule; do
            SCHEDULE_DAY=$(echo $schedule | jq -r '.day_of_week')
            SCHEDULE_TIME=$(echo $schedule | jq -r '.time_utc')
            SCHEDULE_TZ=$(echo $schedule | jq -r '.timezone // "UTC"')
            ORG_URL=$(echo $schedule | jq -r '.org_url')
            ENV_ID=$(echo $schedule | jq -r '.environment_id')
            USER_EMAIL=$(echo $schedule | jq -r '.user_email')
            SCHEDULE_ID=$(echo $schedule | jq -r '.id')
            
            # Get per-user credentials from schedule
            USER_CLIENT_ID=$(echo $schedule | jq -r '.client_id // empty')
            USER_CLIENT_SECRET=$(echo $schedule | jq -r '.client_secret // empty')
            USER_TENANT_ID=$(echo $schedule | jq -r '.tenant_id // empty')
            
            # Get current time in the schedule's timezone
            CURRENT_LOCAL_DAY=$(TZ="$SCHEDULE_TZ" date +%w)
            CURRENT_LOCAL_HOUR=$(TZ="$SCHEDULE_TZ" date +%H):00
            
            echo "Checking schedule $SCHEDULE_ID: Day $SCHEDULE_DAY at $SCHEDULE_TIME ($SCHEDULE_TZ)"
            echo "  Current local time in $SCHEDULE_TZ: Day $CURRENT_LOCAL_DAY, Time $CURRENT_LOCAL_HOUR"
            
            # Validate credentials
            if [ -z "$USER_CLIENT_ID" ] || [ -z "$USER_CLIENT_SECRET" ]; then
              echo "‚ö†Ô∏è Schedule $SCHEDULE_ID missing credentials, skipping"
              continue
            fi
            
            # Check if schedule matches current LOCAL time (in user's timezone)
            if [ "$SCHEDULE_DAY" = "$CURRENT_LOCAL_DAY" ] && [ "$SCHEDULE_TIME" = "$CURRENT_LOCAL_HOUR" ]; then
              echo "‚úÖ Schedule matches! Processing updates for $ORG_URL"
              
              # Get access token for Power Platform API (not Dataverse)
              TOKEN_RESPONSE=$(curl -s -X POST "https://login.microsoftonline.com/${USER_TENANT_ID}/oauth2/v2.0/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "client_id=${USER_CLIENT_ID}&client_secret=${USER_CLIENT_SECRET}&grant_type=client_credentials&scope=https://api.powerplatform.com/.default")
              
              ACCESS_TOKEN=$(echo $TOKEN_RESPONSE | jq -r '.access_token')
              
              if [ "$ACCESS_TOKEN" != "null" ] && [ -n "$ACCESS_TOKEN" ]; then
                echo "üîë Got access token for Power Platform API"
                
                # Fetch installed apps
                echo "üì¶ Fetching installed apps..."
                INSTALLED_APPS=$(curl -s "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages?appInstallState=Installed&api-version=2022-03-01-preview" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Accept: application/json")
                
                # Fetch all catalog apps (to find newer versions)
                echo "üì¶ Fetching catalog apps..."
                CATALOG_APPS=$(curl -s "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages?api-version=2022-03-01-preview" \
                  -H "Authorization: Bearer $ACCESS_TOKEN" \
                  -H "Accept: application/json")
                
                # Find apps with updates and install them
                UPDATED_COUNT=0
                FAILED_COUNT=0
                
                echo "$INSTALLED_APPS" | jq -c '.value[]? // empty' 2>/dev/null | while read installed; do
                  APP_ID=$(echo $installed | jq -r '.applicationId // empty')
                  APP_NAME=$(echo $installed | jq -r '.localizedName // .applicationName // "Unknown"')
                  INSTALLED_VERSION=$(echo $installed | jq -r '.version // "0.0.0"')
                  UNIQUE_NAME=$(echo $installed | jq -r '.uniqueName // empty')
                  
                  if [ -z "$APP_ID" ]; then continue; fi
                  
                  # Find latest version in catalog
                  CATALOG_VERSION=$(echo "$CATALOG_APPS" | jq -r --arg id "$APP_ID" '[.value[]? | select(.applicationId == $id)] | sort_by(.version) | last | .version // "0.0.0"')
                  CATALOG_UNIQUE=$(echo "$CATALOG_APPS" | jq -r --arg id "$APP_ID" '[.value[]? | select(.applicationId == $id)] | sort_by(.version) | last | .uniqueName // empty')
                  
                  # Compare versions (simple string compare works for semver)
                  if [ "$CATALOG_VERSION" != "0.0.0" ] && [ "$CATALOG_VERSION" != "$INSTALLED_VERSION" ]; then
                    # Check if catalog version is higher
                    HIGHER=$(echo -e "$INSTALLED_VERSION\n$CATALOG_VERSION" | sort -V | tail -1)
                    if [ "$HIGHER" = "$CATALOG_VERSION" ] && [ "$HIGHER" != "$INSTALLED_VERSION" ]; then
                      echo "üîÑ Updating $APP_NAME: $INSTALLED_VERSION ‚Üí $CATALOG_VERSION"
                      
                      # Use catalog uniqueName if available, otherwise use installed uniqueName
                      UPDATE_NAME="${CATALOG_UNIQUE:-$UNIQUE_NAME}"
                      
                      UPDATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.powerplatform.com/appmanagement/environments/${ENV_ID}/applicationPackages/${UPDATE_NAME}/install?api-version=2022-03-01-preview" \
                        -H "Authorization: Bearer $ACCESS_TOKEN" \
                        -H "Content-Type: application/json")
                      
                      HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -1)
                      RESPONSE_BODY=$(echo "$UPDATE_RESPONSE" | head -n -1)
                      
                      if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
                        echo "  ‚úÖ Update submitted successfully"
                        UPDATED_COUNT=$((UPDATED_COUNT + 1))
                      else
                        echo "  ‚ùå Update failed: $HTTP_CODE - $RESPONSE_BODY"
                        FAILED_COUNT=$((FAILED_COUNT + 1))
                      fi
                    fi
                  fi
                done
                
                echo "üìä Updates submitted: $UPDATED_COUNT, Failed: $FAILED_COUNT"
                
                # Update last_run status in Supabase
                curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                  -H "apikey: $SUPABASE_SERVICE_KEY" \
                  -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"success\", \"last_run_details\": \"Updated: $UPDATED_COUNT, Failed: $FAILED_COUNT\"}"
                
                echo "‚úÖ Updated schedule $SCHEDULE_ID status to success"
              else
                echo "‚ùå Failed to get access token"
                echo "Token response: $TOKEN_RESPONSE"
                
                # Update status as failed
                curl -s -X PATCH "${SUPABASE_URL}/rest/v1/update_schedules?id=eq.${SCHEDULE_ID}" \
                  -H "apikey: $SUPABASE_SERVICE_KEY" \
                  -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
                  -H "Content-Type: application/json" \
                  -d "{\"last_run_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\", \"last_run_status\": \"failed\", \"last_run_details\": \"Failed to acquire token\"}"
              fi
            else
              echo "‚è≠Ô∏è Schedule $SCHEDULE_ID doesn't match current time, skipping"
            fi
          done
          
          echo "üéâ Done processing schedules"
